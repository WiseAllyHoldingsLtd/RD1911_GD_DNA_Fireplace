#include <cstring>

#include "SystemTestCommunicator.h"
#include "Constants.h"
#include "SpiDriverInterface.h"


uint8_t const SETTINGS_RESET_MAGIC_SEQUENCE[8u] = {0xE2, 0xEC, 0x4F, 0xC2, 0x5C, 0xED, 0x34, 0xB3}; /* Generated by random.org */

#pragma pack(push, 1) /* Structs are packed tightly together because they are used in serialising to a memory buffer. */
struct SystemTestMessageHeader
{
  uint8_t commandType;
  uint8_t length;
};
#pragma pack(pop)

#pragma pack(push, 1)
struct ButtonMessage
{
  SystemTestMessageHeader systemTestMessageHeader;
  uint8_t wasButtonPressedAndReleased[NUMBER_OF_BUTTONS];
  uint8_t isButtonHeld[NUMBER_OF_BUTTONS];
  uint32_t buttonHeldDurationMs[NUMBER_OF_BUTTONS];
  bool isStandbySwitch;
};
#pragma pack(pop)

#pragma pack(push, 1)
struct ClearSettingsMessage
{
  SystemTestMessageHeader header;
  uint8_t magicSequence[sizeof(SETTINGS_RESET_MAGIC_SEQUENCE)];
};
#pragma pack(pop)

#pragma pack(push, 1)
struct LEDViewMessage
{
  SystemTestMessageHeader systemTestMessageHeader;
  char textString[Constants::TEXT_MAX_LENGTH];
  bool isRGBRedActive;
  bool isRGBGreenActive;
  bool isRGBBlueActive;
  bool isYellowLEDActive;
};
#pragma pack(pop)



SystemTestCommunicator::SystemTestCommunicator(SpiDriverInterface &spiDriver) : m_spiDriver(spiDriver),
                                                                                m_simulatedButtonStatus(),
                                                                                m_isSimulatedButtonStatusActive(false),
                                                                                m_shouldClearSettings(false),
                                                                                m_isSimulatedStandbySwitchStatus(false),
                                                                                m_isButtonReset(false)
{
  static_assert(Constants::SYSTEM_TEST_EXPECTED_LED_VIEW_MESSAGE_LENGTH == sizeof(LEDViewMessage), "LEDViewMessage size not as expected");
  static_assert(Constants::SYSTEM_TEST_EXPECTED_BUTTON_MESSAGE_LENGTH == sizeof(ButtonMessage), "ButtonMessage size not as expected");
  static_assert(Constants::SYSTEM_TEST_EXPECTED_LED_VIEW_MESSAGE_LENGTH <= Constants::SPI_SYSTEM_TEST_BUFFER_LENGTH, "SPI buffer not large enough");
  static_assert(Constants::SYSTEM_TEST_EXPECTED_BUTTON_MESSAGE_LENGTH <= Constants::SPI_SYSTEM_TEST_BUFFER_LENGTH, "SPI buffer not large enough");

  m_spiDriver.resetAndInit();
}


bool SystemTestCommunicator::getButtonStatus(ButtonStatus &buttonStatus)
{
  if (m_isSimulatedButtonStatusActive)
  {
    buttonStatus = m_simulatedButtonStatus;
  }
  return m_isSimulatedButtonStatusActive;
}


void SystemTestCommunicator::resetButtonStatus(void)
{
  m_isButtonReset = true;
  m_isSimulatedButtonStatusActive = false;
}

bool SystemTestCommunicator::isSimulatedStandbySwitchActive(void)
{
  // Note: could be repurposed as proximity sensor trigger
  return  m_isSimulatedStandbySwitchStatus;
}

void SystemTestCommunicator::sendViewModelInfo(const ViewModelInterface &viewModel)
{
  uint8_t sendBuffer[Constants::SPI_SYSTEM_TEST_BUFFER_LENGTH] = {};
  serialiseViewModel(sendBuffer, viewModel);
  uint8_t receiveBuffer[Constants::SPI_SYSTEM_TEST_BUFFER_LENGTH] = {};

  m_spiDriver.sendReceive(SpiTarget::SystemTest, sendBuffer, receiveBuffer, Constants::SPI_SYSTEM_TEST_BUFFER_LENGTH);

  ButtonStatus newButtonStatus = {};
  bool shouldClearSettings = false;

  if (deserialiseButtonStatus(&receiveBuffer[Constants::SYSTEM_TEST_REPLY_OFFSET], newButtonStatus))
  {
    bool update = true;
    if (m_isButtonReset) {
      // Special handling of buttons held from systemtest.
      static_assert(NUMBER_OF_BUTTONS == 3u, "Loop unrolled for 3 buttons");
      if ((newButtonStatus.buttonHeldDurationMs[0] > 0u)
          || (newButtonStatus.buttonHeldDurationMs[1] > 0u)
          || (newButtonStatus.buttonHeldDurationMs[2] > 0u)) {
        update = false;
      }
      else {
        update = true;
        m_isButtonReset = false;
      }
    }
    if (update) {
      m_simulatedButtonStatus = newButtonStatus;
      m_isSimulatedButtonStatusActive = true;
    }
  }
  else if (deserialiseClearSettings(&receiveBuffer[Constants::SYSTEM_TEST_REPLY_OFFSET], shouldClearSettings))
  {
    m_shouldClearSettings = shouldClearSettings;
  }
  else
  {
  }
}

bool SystemTestCommunicator::shouldClearSettings(void)
{
  bool clearSettings = m_shouldClearSettings;
  m_shouldClearSettings = false;
  return clearSettings;
}

void SystemTestCommunicator::serialiseViewModel(uint8_t sendBuffer[], const ViewModelInterface &viewModel)
{
  LEDViewMessage viewMessage;

  viewMessage.systemTestMessageHeader.commandType = Constants::SYSTEM_TEST_COMMAND_TYPE_LED_VIEW;
  viewMessage.systemTestMessageHeader.length = Constants::SYSTEM_TEST_EXPECTED_LED_VIEW_MESSAGE_LENGTH;

  memset(viewMessage.textString, 0, static_cast<uint32_t>(Constants::TEXT_MAX_LENGTH));
  strncpy(viewMessage.textString, viewModel.getTextString(), static_cast<uint32_t>(Constants::TEXT_MAX_LENGTH));

  viewMessage.isRGBRedActive = viewModel.isRGBRedActive();
  viewMessage.isRGBGreenActive = viewModel.isRGBGreenActive();
  viewMessage.isRGBBlueActive = viewModel.isRGBBlueActive();
  viewMessage.isYellowLEDActive = viewModel.isYellowLEDActive();

  memcpy(sendBuffer, &viewMessage, sizeof(viewMessage));
}


bool SystemTestCommunicator::deserialiseButtonStatus(uint8_t receiveBuffer[], ButtonStatus &newButtonStatus)
{
  ButtonMessage buttonMessage;
  memcpy(&buttonMessage, receiveBuffer, sizeof(buttonMessage));
  bool isValidMessage = false;
  if ((buttonMessage.systemTestMessageHeader.commandType == Constants::SYSTEM_TEST_COMMAND_TYPE_BUTTON) &&
    (buttonMessage.systemTestMessageHeader.length == Constants::SYSTEM_TEST_EXPECTED_BUTTON_MESSAGE_LENGTH - Constants::SYSTEM_TEST_COMMAND_HEADER_LENGTH))
  {
    isValidMessage = true;

    for (uint16_t i = 0U; i < NUMBER_OF_BUTTONS; i++)
    {
      newButtonStatus.wasButtonPressedAndReleased[i] = static_cast<bool>(buttonMessage.wasButtonPressedAndReleased[i]);
      newButtonStatus.isButtonHeld[i] = static_cast<bool>(buttonMessage.isButtonHeld[i]);
      newButtonStatus.buttonHeldDurationMs[i] = buttonMessage.buttonHeldDurationMs[i];
    }
    m_isSimulatedStandbySwitchStatus = buttonMessage.isStandbySwitch;
  }
  return isValidMessage;
}

bool SystemTestCommunicator::deserialiseClearSettings(uint8_t receiveBuffer[], bool &clearSettings)
{
  ClearSettingsMessage clearSettingsMessage;
  memcpy(&clearSettingsMessage, receiveBuffer, sizeof(clearSettingsMessage));
  bool isValidMessage = false;
  if ((clearSettingsMessage.header.commandType == Constants::SYSTEM_TEST_COMMAND_TYPE_CLEAR_SETTINGS) &&
    (clearSettingsMessage.header.length == Constants::SYSTEM_TEST_EXPECTED_CLEAR_SETTINGS_MESSAGE_LENGTH - Constants::SYSTEM_TEST_COMMAND_HEADER_LENGTH))
  {
    isValidMessage = true;

    if (memcmp(clearSettingsMessage.magicSequence, SETTINGS_RESET_MAGIC_SEQUENCE, sizeof(SETTINGS_RESET_MAGIC_SEQUENCE)) == 0)
    {
      clearSettings = true;
    }
    else
    {
      clearSettings = false;
    }
  }
  return isValidMessage;
}
