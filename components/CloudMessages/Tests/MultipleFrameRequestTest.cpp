#include "CppUTest/TestHarness.h"

#include "MultipleFrameRequest.h"


static FrameParser * frame;
static MultipleFrameRequest * multipleFrame;

TEST_GROUP(MultipleFrameRequestInvalidData)
{
};

TEST(MultipleFrameRequestInvalidData, testFrameIDMustMatch)
{
  uint8_t data[] = {
      0x00, 0x21, // invalid frameID
      0x01, 0x00, // numOfFrames = 1
      0x01, 0x00  // payloadFrame size = 1, payloadByte = 0
  };

  FrameParser parser(data, sizeof(data));
  MultipleFrameRequest mFrame(parser);

  CHECK_FALSE(mFrame.isValid());
}

TEST(MultipleFrameRequestInvalidData, testFrameMinimumLength)
{
  uint8_t data[] = {
      0x00, 0x22, // frameID
      0x00        // numOfFrames incomplete
  };

  FrameParser parser(data, sizeof(data));
  MultipleFrameRequest mFrame(parser);

  CHECK_FALSE(mFrame.isValid());
}

TEST(MultipleFrameRequestInvalidData, testFrameWithNumOfFramesZeroWithCorrectSize)
{
  uint8_t data[] = {
      0x00, 0x22, // frameID
      0x00, 0x00  // numOfFrames complete but zero
  };

  FrameParser parser(data, sizeof(data));
  MultipleFrameRequest mFrame(parser);

  CHECK_TRUE(mFrame.isValid()); // actually valid, even if it is meaningless
  CHECK_EQUAL(0U, mFrame.getNumOfPayloadFrames());
  CHECK_EQUAL(0U, mFrame.getPayloadFrameSize(0U));
}

TEST(MultipleFrameRequestInvalidData, testFrameWithNumOfFramesZeroWithIncorrectSize)
{
  uint8_t data[] = {
      0x00, 0x22, // frameID
      0x00, 0x00,  // numOfFrames complete but zero
      0x00
  };

  FrameParser parser(data, sizeof(data));
  MultipleFrameRequest mFrame(parser);

  CHECK_FALSE(mFrame.isValid());
}

TEST(MultipleFrameRequestInvalidData, testMultiplePayloadFrameWithSizeMismatch)
{
  uint8_t data[] = {
      0x00, 0x22,  // frameID
      0x03, 0x00,  // numOfFrames complete but zero
      0x01, 0x02,  // payload#0, size + byte
      0x03, 0xaa, 0xbb, // payload#1, size + bytes (one missing)
      0x04, 0xc0, 0xc1, 0xc2, 0xc3 // payload#2, size + bytes
  };

  FrameParser parser(data, sizeof(data));
  MultipleFrameRequest mFrame(parser);

  CHECK_FALSE(mFrame.isValid());
}



TEST_GROUP(MultipleFrameRequestValidSinglePayload)
{
  TEST_SETUP()
  {
    uint8_t data[] = {
        0x00, 0x22, // frameID (MSB)
        0x01, 0x00, // numOfFrames
        0x04,       // payload size
        0x5b, 0x05, 0x20, 0x1c
    };

    frame = new FrameParser(data, sizeof(data));
    multipleFrame = new MultipleFrameRequest(*frame);
  }

  TEST_TEARDOWN()
  {
    delete multipleFrame;
    delete frame;
  }
};

TEST(MultipleFrameRequestValidSinglePayload, testValidation)
{
  CHECK_TRUE(multipleFrame->isValid());
}

TEST(MultipleFrameRequestValidSinglePayload, testNumberOfPayloadFrames)
{
  CHECK_EQUAL(1U, multipleFrame->getNumOfPayloadFrames());
}

TEST(MultipleFrameRequestValidSinglePayload, testPayloadFrameData)
{
  uint8_t expectedBytes[] = { 0x5b, 0x05, 0x20, 0x1c };

  uint8_t payloadSize = multipleFrame->getPayloadFrameSize(0U);
  uint8_t * payloadBytes = new uint8_t[payloadSize];
  uint8_t returnedBytes = multipleFrame->getPayloadFrame(0U, payloadBytes, payloadSize);

  CHECK_EQUAL(4U, payloadSize);
  CHECK_EQUAL(4U, returnedBytes);
  MEMCMP_EQUAL(expectedBytes, payloadBytes, 4U);

  delete [] payloadBytes;
}

TEST(MultipleFrameRequestValidSinglePayload, testPayloadFrameDataForOutOfBoundsPayloadFrame)
{
  uint8_t payloadSize = multipleFrame->getPayloadFrameSize(1U);
  uint8_t * payloadBytes = new uint8_t[1U];
  uint8_t returnedBytes = multipleFrame->getPayloadFrame(1U, payloadBytes, payloadSize);

  CHECK_EQUAL(0U, payloadSize);
  CHECK_EQUAL(0U, returnedBytes);

  delete [] payloadBytes;
}



TEST_GROUP(MultipleFrameRequestValidSeveralPayloadFrames)
{
  TEST_SETUP()
  {
    uint8_t data[] = {
        0x00, 0x22, // frameID (MSB)
        0x04, 0x00, // numOfFrames
        0x04,       // payload#0 size
        0x12, 0x34, 0x45, 0x67, // payload#0 bytes
        0x01,       // payload#1 size
        0xab,       // payload#1 bytes
        0x11,       // payload#2 size
        0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf, 0x10, // payload#2 bytes
        0x03,       // payload#3 size
        0x11, 0x22, 0x33 // payload#3 bytes
    };

    frame = new FrameParser(data, sizeof(data));
    multipleFrame = new MultipleFrameRequest(*frame);
  }

  TEST_TEARDOWN()
  {
    delete multipleFrame;
    delete frame;
  }
};

TEST(MultipleFrameRequestValidSeveralPayloadFrames, testThatNumOfFramesReportsCorrectForVeryLargeNumOfFrames)
{
  uint8_t data[] = {
      0x00, 0x22, // valid frameID
      0x02, 0x01, // numOfFrames = 258
      0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00,
      0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00,
      0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00,
      0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, // 64
      0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00,
      0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00,
      0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00,
      0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, // 128
      0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00,
      0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00,
      0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00,
      0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, // 192
      0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00,
      0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00,
      0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00,
      0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00, // 256
      0x01, 0x00, 0x01, 0x00
  };

  FrameParser parser(data, sizeof(data));
  MultipleFrameRequest frame(parser);

  CHECK_TRUE(frame.isValid());
  CHECK_EQUAL(258U, frame.getNumOfPayloadFrames());
}

TEST(MultipleFrameRequestValidSeveralPayloadFrames, testValidation)
{
  CHECK_TRUE(multipleFrame->isValid());
}

TEST(MultipleFrameRequestValidSeveralPayloadFrames, testNumberOfPayloadFrames)
{
  CHECK_EQUAL(4U, multipleFrame->getNumOfPayloadFrames());
}

TEST(MultipleFrameRequestValidSeveralPayloadFrames, testPayloadFrameData)
{
  uint8_t expectedBytes0[] = { 0x12, 0x34, 0x45, 0x67 };
  uint8_t expectedBytes1[] = { 0xab };
  uint8_t expectedBytes2[] = { 0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf, 0x10 };
  uint8_t expectedBytes3[] = { 0x11, 0x22, 0x33 };

  // Payload #0
  uint16_t payloadNum = 0U;
  uint8_t payloadSize = multipleFrame->getPayloadFrameSize(payloadNum);
  uint8_t * payloadBytes = new uint8_t[payloadSize];
  uint8_t returnedBytes = multipleFrame->getPayloadFrame(payloadNum, payloadBytes, payloadSize);
  CHECK_EQUAL(4U, payloadSize);
  CHECK_EQUAL(4U, returnedBytes);
  MEMCMP_EQUAL(expectedBytes0, payloadBytes, 4U);
  delete [] payloadBytes;

  payloadNum = 1U;
  payloadSize = multipleFrame->getPayloadFrameSize(payloadNum);
  payloadBytes = new uint8_t[payloadSize];
  returnedBytes = multipleFrame->getPayloadFrame(payloadNum, payloadBytes, payloadSize);
  CHECK_EQUAL(1U, payloadSize);
  CHECK_EQUAL(1U, returnedBytes);
  MEMCMP_EQUAL(expectedBytes1, payloadBytes, 1U);
  delete [] payloadBytes;

  payloadNum = 2U;
  payloadSize = multipleFrame->getPayloadFrameSize(payloadNum);
  payloadBytes = new uint8_t[payloadSize];
  returnedBytes = multipleFrame->getPayloadFrame(payloadNum, payloadBytes, payloadSize);
  CHECK_EQUAL(17U, payloadSize);
  CHECK_EQUAL(17U, returnedBytes);
  MEMCMP_EQUAL(expectedBytes2, payloadBytes, 17U);
  delete [] payloadBytes;

  payloadNum = 3U;
  payloadSize = multipleFrame->getPayloadFrameSize(payloadNum);
  payloadBytes = new uint8_t[payloadSize];
  returnedBytes = multipleFrame->getPayloadFrame(payloadNum, payloadBytes, payloadSize);
  CHECK_EQUAL(3U, payloadSize);
  CHECK_EQUAL(3U, returnedBytes);
  MEMCMP_EQUAL(expectedBytes3, payloadBytes, 3U);
  delete [] payloadBytes;
}
